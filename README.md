# 🏗️ AWS Infrastructure Migration Project using Terraform

This repository contains an end-to-end project for migrating and managing AWS infrastructure
using **Terraform**, including **importing existing resources**, **state management**, and extending
the setup for **drift detection and notifications**.

It documents the process of provisioning infrastructure, importing existing AWS resources into Terraform,
managing Terraform state files, resolving challenges, and setting up CI/CD pipelines or AWS Lambda for monitoring.

---

## 🚀 **Project Overview**

✅ The infrastructure was initially provisioned using Terraform scripts in a folder named
`terraform_old`.

✅ Later, a migration effort was performed to import existing AWS resources into a new
Terraform-managed state in `terraform_new`, using:

- `terraform import`
- a **Python automation script**
- [`Terraformer`](https://github.com/GoogleCloudPlatform/terraformer)

✅ Finally, state files were merged to have a consolidated view of the infrastructure
under Terraform management.

---

## 🏗️ **Phases of the Project**

### 1️⃣ **Initial Provisioning (`terraform_old/`)**

- Infrastructure was first provisioned manually with Terraform in a folder called
  `terraform_old`.
- This included resources like:
  - VPC
  - Subnets
  - Security Groups
  - EC2 Instances
  - RDS
  - EKS Cluster

✅ The infrastructure was successfully deployed using Terraform.

---

### 2️⃣ **Resetting State for Migration**

- To simulate a migration of existing infrastructure, the Terraform state was deleted
  (by removing `terraform.tfstate`), leaving the infrastructure deployed in AWS
  but **untracked by Terraform**.

📝 **Goal:** re-import these resources back into Terraform management.

---


### 3️⃣ **New Project Setup (`terraform_new/`)**

A new folder `terraform_new/` was created to manage the same infrastructure:

✅ New Terraform configuration files were written:
- `main.tf`
- `variables.tf`
- `outputs.tf`
- `provider.tf`
- `terraform.tfvars`

### 💡 **Opportunity for Improvement:**

👉 The Terraform configuration can be further modularized by splitting resources into modules:
- `modules/network`
- `modules/compute`
- `modules/database`
- `modules/eks`

This would improve **reusability, scalability, and maintainability.**

---

## 📥 **Importing Existing Resources**

We used **three approaches** to import existing AWS resources:

---

### 4️⃣ **A. Using `terraform import` command**

✅ Each resource was imported manually:

```bash
terraform import aws_vpc.main vpc-xxxxxxxx
terraform import aws_subnet.a subnet-xxxxxxxx
terraform import aws_instance.ec2["web1"] i-xxxxxxxx
...
````

🔍 This approach required mapping every resource to its Terraform configuration.

---

### 5️⃣ **B. Using a Python Script for Automation**

✅ A Python script `import_script.py` was created to automate `terraform import` commands for multiple resources.

🔗 This reduced manual effort, but still required prior knowledge of resource IDs.

---

### 6️⃣ **C. Using Terraformer**

We also used [`Terraformer`](https://github.com/GoogleCloudPlatform/terraformer) — a tool that automatically generates Terraform configuration and state from existing infrastructure.

Installed Terraformer and verified version:

```bash
terraformer --version
```

Ran import command for AWS S3:

```bash
terraformer import aws \
  --resources=s3 \
  --regions=us-east-1 \
  --profile=default \
  --output generated \
  --path-pattern "{output}/{provider}/{service}" \
  --compact \
  -O hcl
```

✅ Generated `.tf` and `terraform.tfstate` files under `generated/aws/s3/`.

---

## 🗃️ **Merging State Files**

We had two state files:

1. `terraform.tfstate` → tracked by Terraform in `terraform_new`
2. `generated/aws/s3/terraform.tfstate` → generated by Terraformer

### 🛠️ We merged these by:

✅ Listing Terraformer state:

```bash
terraform state list -state=generated/aws/s3/terraform.tfstate
```

✅ Moving Terraformer resources into main state:

```bash
terraform state mv \
  -state=generated/aws/s3/terraform.tfstate \
  'aws_s3_bucket.tfer--1-terrraform-migration' \
  'aws_s3_bucket.buckets["1-terrraform-migration"]'
```

✅ Verified merged state:

```bash
terraform state list
```

---

## ⚠️ **Challenges Faced & Resolutions**


````markdown
## ⚠️ **Challenges Faced & Resolutions**

✅ **Issue:** `fork/exec : no such file or directory` when running `terraformer`  
👉 **Resolution:**  
- Verified `terraformer` binary existed in the working directory  
- Made it executable with `chmod +x terraformer`  
- Added directory to `$PATH`:  

```bash
export PATH=$PATH:/path/to/terraformer-directory
````

* Confirmed installation using:

```bash
terraformer --version
```

---

✅ **Issue:** Terraformer-generated resource names had unexpected prefixes like `tfer--1-terraform-migration`
👉 **Resolution:**
Used `terraform state mv` to **rename resources** to match expected naming convention:

```bash
terraform state mv \
  -state=generated/aws/s3/terraform.tfstate \
  'aws_s3_bucket.tfer--1-terraform-migration' \
  'aws_s3_bucket.buckets["1-terraform-migration"]'
```

✅ Important: wrapped destination address in **quotes** to handle brackets.

---

✅ **Issue:** Error merging state files (e.g. `lineage mismatch`, `cannot overwrite state`)
👉 **Resolution:**
Avoided using `terraform state push merged.tfstate` (which failed due to different lineage IDs).
Instead, migrated resources **one by one** from Terraformer-generated state into main state:

```bash
terraform state list -state=generated/aws/s3/terraform.tfstate

terraform state mv \
  -state=generated/aws/s3/terraform.tfstate \
  'aws_s3_bucket.tfer--2-terraform-migration' \
  'aws_s3_bucket.buckets["2-terraform-migration"]'
```

✅ This preserved state integrity while consolidating states.

---

✅ **Issue:** Errors in `terraform state mv` when importing indexed resources (like `aws_s3_bucket.buckets["bucket-name"]`)
👉 **Resolution:**
Always wrapped resource addresses with **single quotes** to avoid CLI parsing issues:

```bash
terraform state mv \
  'aws_s3_bucket.tfer--3-terraform-migration' \
  'aws_s3_bucket.buckets["3-terraform-migration"]'
```

✅ Without quotes → Terraform CLI would throw a syntax error.

---

🎉 These resolutions ensured a **clean migration from Terraformer-generated state → main Terraform-managed state** without breaking state lineage or causing import conflicts.

```

---

✅ **You can paste this directly into your README, replacing the old Challenges & Resolutions section!**  
✅ It’s clean, Markdown-formatted, and fits your earlier style.

Let me know if you want it more minimal or expanded! 🚀
```

---

## 📝 **Future Enhancements**

✅ To further improve infrastructure monitoring and drift detection:

1. 🟢 **Write a Lambda function** that periodically:

   * Checks CloudWatch logs for changes
   * Or monitors other drift indicators
   * Sends notifications via SES/SNS/Email

2. 🟢 **Implement CI/CD pipeline** (e.g. GitHub Actions, GitLab CI, Jenkins, or AWS CodePipeline) to:

   * Automatically run `terraform plan` on a schedule
   * Detect drifts programmatically
   * Alert teams on discrepancies

---

## 📂 **Repository Structure**

```bash
aws-migration-project/
├── terraform_old/           # Initial infrastructure scripts
├── terraform_new/           # Migrated infrastructure scripts
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf
│   ├── provider.tf
│   ├── terraform.tfvars
│   └── terraform.tfstate
├── generated/               # Terraformer generated files
├── import_script.py         # Python import automation script
└── README.md
```

---

## 🏁 **Final Notes**

✅ This project showcases **a full migration workflow from unmanaged infrastructure → Terraform-managed**.

✅ Explores **multiple import methods**, **state file manipulation**, **resolving import conflicts**, and lays a foundation for **drift detection automation**.

```
