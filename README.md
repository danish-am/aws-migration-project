# ğŸ—ï¸ AWS Infrastructure Migration Project using Terraform

This repository contains an end-to-end project for migrating and managing AWS infrastructure
using **Terraform**, including **importing existing resources**, **state management**, and extending
the setup for **drift detection and notifications**.

It documents the process of provisioning infrastructure, importing existing AWS resources into Terraform,
managing Terraform state files, resolving challenges, and setting up CI/CD pipelines or AWS Lambda for monitoring.

---

## ğŸš€ **Project Overview**

âœ… The infrastructure was initially provisioned using Terraform scripts in a folder named
`terraform_old`.

âœ… Later, a migration effort was performed to import existing AWS resources into a new
Terraform-managed state in `terraform_new`, using:

- `terraform import`
- a **Python automation script**
- [`Terraformer`](https://github.com/GoogleCloudPlatform/terraformer)

âœ… Finally, state files were merged to have a consolidated view of the infrastructure
under Terraform management.

---

## ğŸ—ï¸ **Phases of the Project**

### 1ï¸âƒ£ **Initial Provisioning (`terraform_old/`)**

- Infrastructure was first provisioned manually with Terraform in a folder called
  `terraform_old`.
- This included resources like:
  - VPC
  - Subnets
  - Security Groups
  - EC2 Instances
  - RDS
  - EKS Cluster

âœ… The infrastructure was successfully deployed using Terraform.

---

### 2ï¸âƒ£ **Resetting State for Migration**

- To simulate a migration of existing infrastructure, the Terraform state was deleted
  (by removing `terraform.tfstate`), leaving the infrastructure deployed in AWS
  but **untracked by Terraform**.

ğŸ“ **Goal:** re-import these resources back into Terraform management.

---


### 3ï¸âƒ£ **New Project Setup (`terraform_new/`)**

A new folder `terraform_new/` was created to manage the same infrastructure:

âœ… New Terraform configuration files were written:
- `main.tf`
- `variables.tf`
- `outputs.tf`
- `provider.tf`
- `terraform.tfvars`

### ğŸ’¡ **Opportunity for Improvement:**

ğŸ‘‰ The Terraform configuration can be further modularized by splitting resources into modules:
- `modules/network`
- `modules/compute`
- `modules/database`
- `modules/eks`

This would improve **reusability, scalability, and maintainability.**

---

## ğŸ“¥ **Importing Existing Resources**

We used **three approaches** to import existing AWS resources:

---

### 4ï¸âƒ£ **A. Using `terraform import` command**

âœ… Each resource was imported manually:

```bash
terraform import aws_vpc.main vpc-xxxxxxxx
terraform import aws_subnet.a subnet-xxxxxxxx
terraform import aws_instance.ec2["web1"] i-xxxxxxxx
...
````

ğŸ” This approach required mapping every resource to its Terraform configuration.

---

### 5ï¸âƒ£ **B. Using a Python Script for Automation**

âœ… A Python script `import_script.py` was created to automate `terraform import` commands for multiple resources.

ğŸ”— This reduced manual effort, but still required prior knowledge of resource IDs.

---

### 6ï¸âƒ£ **C. Using Terraformer**

We also used [`Terraformer`](https://github.com/GoogleCloudPlatform/terraformer) â€” a tool that automatically generates Terraform configuration and state from existing infrastructure.

Installed Terraformer and verified version:

```bash
terraformer --version
```

Ran import command for AWS S3:

```bash
terraformer import aws \
  --resources=s3 \
  --regions=us-east-1 \
  --profile=default \
  --output generated \
  --path-pattern "{output}/{provider}/{service}" \
  --compact \
  -O hcl
```

âœ… Generated `.tf` and `terraform.tfstate` files under `generated/aws/s3/`.

---

## ğŸ—ƒï¸ **Merging State Files**

We had two state files:

1. `terraform.tfstate` â†’ tracked by Terraform in `terraform_new`
2. `generated/aws/s3/terraform.tfstate` â†’ generated by Terraformer

### ğŸ› ï¸ We merged these by:

âœ… Listing Terraformer state:

```bash
terraform state list -state=generated/aws/s3/terraform.tfstate
```

âœ… Moving Terraformer resources into main state:

```bash
terraform state mv \
  -state=generated/aws/s3/terraform.tfstate \
  'aws_s3_bucket.tfer--1-terrraform-migration' \
  'aws_s3_bucket.buckets["1-terrraform-migration"]'
```

âœ… Verified merged state:

```bash
terraform state list
```

---

## âš ï¸ **Challenges Faced & Resolutions**

````markdown
## âš ï¸ **Challenges Faced & Resolutions**

Throughout this migration project, we faced several technical challenges across different phases: manual import, Python automation, and Terraformer-generated state.

Below is a detailed breakdown of these challenges and how we resolved them.

---

### âœ… **1. Terraform Import & Python Automation Phase**

We initially attempted to import resources manually using `terraform import`, like:

```bash
terraform import aws_vpc.main vpc-xxxxxxxx
terraform import aws_subnet.a subnet-xxxxxxxx
terraform import aws_instance.ec2["web1"] i-xxxxxxxx
````

âœ… **Issue:** Manually importing each resource was tedious and error-prone.

ğŸ‘‰ **Resolution:** Created an automation script `import_script.py` to batch `terraform import` commands for multiple resources, reading from a predefined list.

âœ… **Issue:** Even after importing, some resources required **additional attributes configured in `main.tf`**, or Terraform would mark them for changes.

ğŸ‘‰ **Resolution:** Manually updated `main.tf` to include missing attributes (e.g. `tags`, `encryption`, `acl`) to match live AWS configuration.

---

### âœ… **2. Terraformer-generated State Phase**

We used **Terraformer** to auto-generate Terraform configuration + state:

```bash
terraformer import aws --resources=s3 --regions=us-east-1 --output=generated --path-pattern="{output}/{provider}/{service}"
```

Terraformer created:

```
generated/aws/s3/terraform.tfstate
generated/aws/s3/resources.tf
```

âœ… **Issue:** Terraformer-generated resource names had unexpected prefixes like `tfer--1-terraform-migration`.

ğŸ‘‰ **Resolution:**

We listed resources from Terraformerâ€™s state:

```bash
terraform state list -state=generated/aws/s3/terraform.tfstate
```

We used `terraform state mv` to migrate resources from Terraformerâ€™s state into the main Terraform state file:

```bash
terraform state mv \
  -state=generated/aws/s3/terraform.tfstate \
  'aws_s3_bucket.tfer--1-terraform-migration' \
  'aws_s3_bucket.buckets["1-terraform-migration"]'
```

âœ… Important: wrapped destination resource address in **quotes** to handle brackets in the name.

---

### âœ… **3. State Merge & Lineage Conflict**

We tried directly merging Terraformerâ€™s state into main state:

```bash
terraform state push merged.tfstate
```

âœ… **Issue:** Failed with `lineage mismatch` / `cannot overwrite existing state` errors.

ğŸ‘‰ **Resolution:**
Instead of pushing a merged file, we **moved each resource one by one** using `terraform state mv`, which preserved state lineage and prevented corruption.

âœ… This kept state integrity while consolidating resources.

---

### âœ… **4. Resource Addressing Syntax**

âœ… **Issue:** Errors in `terraform state mv` when importing indexed resources like `aws_s3_bucket.buckets["bucket-name"]`.

ğŸ‘‰ **Resolution:**
We wrapped resource addresses in **single quotes** to avoid CLI parsing errors:

```bash
terraform state mv \
  'aws_s3_bucket.tfer--3-terraform-migration' \
  'aws_s3_bucket.buckets["3-terraform-migration"]'
```

âœ… Without quotes â†’ Terraform CLI would throw a syntax error.

---

### âœ… **5. Final State Validation**

After migrating all resources:

âœ… Ran `terraform state list` to confirm resources successfully transferred into `terraform_new/terraform.tfstate`.

âœ… Verified infrastructure consistency with:

```bash
terraform plan
```

ğŸ” Ensured Terraform showed **â€œNo changesâ€**, confirming that imported resources matched the Terraform configuration.

---

## ğŸ¯ **Summary Workflow**

1. Initial infrastructure was imported manually via `terraform import` and automated using `import_script.py`.
2. Terraformer generated additional resources + state under `generated/aws/s3/`.
3. We listed Terraformer state resources and mapped them to desired names.
4. Used `terraform state mv` to move resources from Terraformer state â†’ into `terraform_new/terraform.tfstate`.
5. Handled renaming, quoting, lineage conflicts manually.
6. Validated merged state by listing resources and running `terraform plan`.

âœ… This enabled **a clean migration into a single consolidated Terraform-managed state file**, with no plan drift.

---
ğŸ‰ These resolutions ensured **state integrity, no drift detection issues, and a successful infrastructure migration**.
---

## ğŸ“ **Future Enhancements**

âœ… To further improve infrastructure monitoring and drift detection:

1. ğŸŸ¢ **Write a Lambda function** that periodically:

   * Checks CloudWatch logs for changes
   * Or monitors other drift indicators
   * Sends notifications via SES/SNS/Email

2. ğŸŸ¢ **Implement CI/CD pipeline** (e.g. GitHub Actions, GitLab CI, Jenkins, or AWS CodePipeline) to:

   * Automatically run `terraform plan` on a schedule
   * Detect drifts programmatically
   * Alert teams on discrepancies

---

## ğŸ“‚ **Repository Structure**

```bash
aws-migration-project/
â”œâ”€â”€ terraform_old/           # Initial infrastructure scripts
â”œâ”€â”€ terraform_new/           # Migrated infrastructure scripts
â”‚   â”œâ”€â”€ main.tf
â”‚   â”œâ”€â”€ variables.tf
â”‚   â”œâ”€â”€ outputs.tf
â”‚   â”œâ”€â”€ provider.tf
â”‚   â”œâ”€â”€ terraform.tfvars
â”‚   â””â”€â”€ terraform.tfstate
â”œâ”€â”€ generated/               # Terraformer generated files
â”œâ”€â”€ import_script.py         # Python import automation script
â””â”€â”€ README.md
```

---

## ğŸ **Final Notes**

âœ… This project showcases **a full migration workflow from unmanaged infrastructure â†’ Terraform-managed**.

âœ… Explores **multiple import methods**, **state file manipulation**, **resolving import conflicts**, and lays a foundation for **drift detection automation**
